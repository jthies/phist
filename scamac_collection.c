#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

#include "scamac_include.h"
#include "scamac_collection.h"
#include "scamac_internal.h"

// includes headers of all matrix examples. Autogenerated.
#include "scamac_collection_inc.h"

ScamacErrorCode scamac_generator_obtain(const char * matname, ScamacGenerator ** gen) {

  //include code for all matrix examples. Autogenerated.
#include "scamac_collection_example_inc.c"

  return SCAMAC_EFAIL;
}

ScamacErrorCode scamac_generator_set_int(ScamacGenerator * gen, const char * parname, int val) {
  if (gen && parname) {
    gen->needs_finalization = true; // mark as "tainted"

#include "scamac_collection_set_int_inc.c"

    // printf("%s: Unknown example [%s]\n",__func__,gen->name);
    // exit(EXIT_FAILURE);
    // return 0;
    return SCAMAC_EFAIL;
  } else {
    return SCAMAC_EINVAL;
  }
}

ScamacErrorCode scamac_generator_set_double(ScamacGenerator * gen, const char * parname, double val) {
  if (gen && parname) {
    gen->needs_finalization = true; // mark as "tainted"

#include "scamac_collection_set_double_inc.c"

    //printf("%s: Unknown example [%s]\n",__func__,gen->name);
    //exit(EXIT_FAILURE);
    //return 0;
    return SCAMAC_EFAIL;
  } else {
    return SCAMAC_EINVAL;
  }
}

ScamacErrorCode scamac_generator_set_bool(ScamacGenerator * gen, const char * parname, bool val) {
  if (gen && parname) {
    gen->needs_finalization = true; // mark as "tainted"

#include "scamac_collection_set_bool_inc.c"

    //printf("%s: Unknown example [%s]\n",__func__,gen->name);
    //exit(EXIT_FAILURE);
    //return 0;
    return SCAMAC_EFAIL;
  } else {
    return SCAMAC_EINVAL;
  }
}

ScamacErrorCode scamac_generator_set_option(ScamacGenerator * gen, const char * parname, char * option);

ScamacErrorCode scamac_list_examples(char ** desc) {
  if (desc) {
    char * my_string;
#include "scamac_collection_list_examples_inc.c"
    *desc = my_string;
    return SCAMAC_EOK;
  } else {
    return SCAMAC_ENULL;
  }
}

ScamacErrorCode scamac_example_desc(const char * matname, int * valtype, int * symmetry, char ** desc) {
  if (matname) {

#include "scamac_collection_example_desc_inc.c"

    return SCAMAC_EFAIL;
  } else {
    return SCAMAC_ENULL;
  }
}

ScamacErrorCode scamac_example_parameters(const char * matname, char ** desc) {
  if ( (!matname) || (!desc) ) {
    return SCAMAC_ENULL;
  }

  char * my_string;
#include "scamac_collection_list_parameters_inc.c"

  // unknown example
  if (*desc) {
    *desc=NULL;
  }
  return SCAMAC_EFAIL;

}

ScamacPar scamac_identify_parameter(const char * matname, const char * parname) {
  if (matname && parname) {
#include "scamac_collection_identify_parameter_inc.c"
    return SCAMAC_PAR_NONE; // not found
  } else {
    return SCAMAC_PAR_NONE;
  }
}

static char * strip_string(char * s) {
  if (s) {
    while (*s == ' ') {
      s++;
    }
    int n = strlen(s);
    while (n>0 && s[n-1] == ' ') {
      s[n-1]=0;
      n--;
    }
    return s;
  } else {
    return NULL;
  }
}


ScamacErrorCode scamac_generator_parameter_desc(const ScamacGenerator * gen, char ** desc) {
  if ( (!gen) || (!desc) ) {
    return SCAMAC_ENULL;
  }

  char * my_string;
#include "scamac_collection_example_data_inc.c"

  *desc = NULL;
  return SCAMAC_EFAIL;
}

static int split_string(const char *s, char **split, char ***sfst) {
  if (s) {

    // strdup
    char * s2;
    s2 = malloc((strlen(s)+1) * sizeof *s2);
    memcpy(s2, s, strlen(s) * sizeof *s2);
    s2[strlen(s)]=0;

    // first: count

    int n=0;
    char * s1 = s2;

    while (s1) {
      n++;
      s1 = strpbrk(s1, ",");
      if (s1) {
        s1++;
      }
    }

    // second: split

    char ** my_list = malloc( 2* n * sizeof *my_list);

    // split at ","
    s1 = s2;
    n=0;
    while (s1) {
      my_list[2*n]=s1;
      my_list[2*n+1]=NULL;
      n++;
      s1 = strpbrk(s1, ",");
      if (s1) {
        *s1=0; // NULL terminate string
        s1++;
      }
    }

    // split each at "="
    int i;
    for (i=0; i<n; i++) {
      s1 = strpbrk(my_list[2*i], "=");
      if (s1) {
        *s1=0;
        my_list[2*i+1]=s1+1;
      }
    }

    // strip
    for (i=0; i<2*n; i++) {
      if (my_list[i]) {
        my_list[i]=strip_string(my_list[i]);
      }
    }

    *split = s2;
    *sfst = my_list;
    return n;

  } else {
    *split=NULL;
    *sfst=NULL;
    return 0;
  }
}

static bool atobool(const char * bs) {
  if (bs) {
    if (!strcmp(bs,"true")) {
      return true;
    } else if (!strcmp(bs,"false")) {
      return false;
    } else {
      printf("%s: no boolean value.\n",__func__);
      exit(EXIT_FAILURE);
    }
  } else {
    return false;
  }
}

ScamacErrorCode scamac_parse_argstr(const char * argstr, ScamacGenerator **gen, char ** errdesc) {

  ScamacErrorCode err;

  if (!argstr) {
    if (errdesc) {
      char *str = malloc(SCAMAC_NAME_LENGTH * sizeof *str);
      snprintf(str,SCAMAC_NAME_LENGTH,"missing argstr");
      *errdesc = str;
    }
    return SCAMAC_ENULL;
  }

  if (!gen) {
    if (errdesc) {
      char *str = malloc(SCAMAC_NAME_LENGTH * sizeof *str);
      snprintf(str,SCAMAC_NAME_LENGTH,"gen. pointer = NULL");
      *errdesc = str;
    }
    return SCAMAC_ENULL;
  }

  ScamacGenerator * my_gen;

  char * my_s=NULL;
  char ** my_slst=NULL;

  // TODO : free memory allocated here
  int n = split_string(argstr, &my_s, &my_slst);


  if (n<1) {
    if (errdesc) {
      char *str = malloc(SCAMAC_NAME_LENGTH * sizeof *str);
      snprintf(str,SCAMAC_NAME_LENGTH,"few parameters");
      *errdesc = str;
    }
    return SCAMAC_EFAIL;
  }

  // matrix name
  if (my_slst[1]) {
    if (errdesc) {
      char *str = malloc(SCAMAC_NAME_LENGTH * sizeof *str);
      snprintf(str,SCAMAC_NAME_LENGTH,"matrix name accepts no values");
      *errdesc = str;
    }
    return SCAMAC_EFAIL;
  }

  if (!my_slst[0]) {
    if (errdesc) {
      char *str = malloc(SCAMAC_NAME_LENGTH * sizeof *str);
      snprintf(str,SCAMAC_NAME_LENGTH,"matrix name required");
      *errdesc = str;
    }
    return SCAMAC_EFAIL;
  }

  err =  scamac_generator_obtain(my_slst[0], &my_gen);

  if (err) {
    if (errdesc) {
      char *str = malloc(SCAMAC_NAME_LENGTH * sizeof *str);
      snprintf(str,SCAMAC_NAME_LENGTH,"matrix >%s< does not exist",my_slst[0]);
      *errdesc = str;
    }
    return SCAMAC_EFAIL;
  }

  char *my_par = NULL;
  err = scamac_example_parameters(my_slst[0], &my_par);

  if (err) {
    if (errdesc) {
      char *str = malloc(SCAMAC_NAME_LENGTH * sizeof *str);
      snprintf(str,SCAMAC_NAME_LENGTH,"matrix >%s< has no parameters",my_slst[0]);
      *errdesc = str;
    }
    return SCAMAC_EFAIL;
  }


  // set parameters
  int i;
  for (i=1; i<n; i++) {
    ScamacPar par_type = scamac_identify_parameter(my_slst[0],my_slst[2*i]);
    if (par_type == SCAMAC_PAR_NONE) {
      if (errdesc) {
        char *str = malloc(SCAMAC_NAME_LENGTH * sizeof *str);
        snprintf(str,SCAMAC_NAME_LENGTH,"Parameter %s does not exist",my_slst[2*i]);
        *errdesc = str;
      }
      return SCAMAC_EFAIL;
    }
    if (par_type == SCAMAC_PAR_INT) {
      if (!my_slst[2*i+1]) {
        if (errdesc) {
          char *str = malloc(SCAMAC_NAME_LENGTH * sizeof *str);
          snprintf(str,SCAMAC_NAME_LENGTH,"Parameter %s requires INT value",my_slst[2*i]);
          *errdesc = str;
        }
        return SCAMAC_EFAIL;
      }
      scamac_generator_set_int(my_gen, my_slst[2*i], atoi(my_slst[2*i+1]) );
    } else if (par_type == SCAMAC_PAR_DOUBLE) {
      if (!my_slst[2*i+1]) {
        if (errdesc) {
          char *str = malloc(SCAMAC_NAME_LENGTH * sizeof *str);
          snprintf(str,SCAMAC_NAME_LENGTH,"Parameter %s requires DOUBLE value",my_slst[2*i]);
          *errdesc = str;
        }
        return SCAMAC_EFAIL;
      }
      scamac_generator_set_double(my_gen, my_slst[2*i], atof(my_slst[2*i+1]) );
    } else if (par_type == SCAMAC_PAR_BOOL) {
      if (!my_slst[2*i+1]) {
        if (errdesc) {
          char *str = malloc(SCAMAC_NAME_LENGTH * sizeof *str);
          snprintf(str,SCAMAC_NAME_LENGTH,"Parameter %s requires BOOL value",my_slst[2*i]);
          *errdesc = str;
        }
        return SCAMAC_EFAIL;
      }
      scamac_generator_set_bool(my_gen, my_slst[2*i], atobool(my_slst[2*i+1]) );
    } else {
      if (errdesc) {
        char *str = malloc(SCAMAC_NAME_LENGTH * sizeof *str);
        snprintf(str,SCAMAC_NAME_LENGTH,"Unknown parameter type");
        *errdesc = str;
      }
      return SCAMAC_EFAIL;
    }
  }

  free(my_s);
  free(my_slst);
  free(my_par);

  *gen =  my_gen;
  if (errdesc) {
    *errdesc = NULL;
  }
  return SCAMAC_EOK;

}

const char * scamac_desc_err(ScamacErrorCode err) {
  const int MaxErrorN = 13;
  /* This array must agree with the def. of ScamacErrorCode in scamac_include.h */
  static const char *ErrorStrings[] = {
    /* OK */ "OK",
    /* FAIL */ "Failed for no reason",
    /* UNKNOWN */ "Unknown",
    /* SHORTROW */ "Short row",
    /* RANGE */ "Parameter out of range",
    /* INVALID */ "Invalid parameters",
    /* NULL */ "Unexpected NULL pointer",
    /* OVERFLOW */ "Matrix size exceeds INT_MAX",
    /* MALLOCFAIL */ "Memory allocation failed",
    /* HUGEINT */ "An integer parameters is too large",
    /* HUGECOMP */ "A computed integer is too large",
    /* WARNING */ "Warning",
    /* INVAL */ "Wrong input parameter",
    /* NOTCONVERGED */ "Failed to converged"
  };
  err = err & ~SCAMAC_EINTERNAL; // get rid of "internal" flag
  if (((int) err<0)||(err>MaxErrorN)) {
    err = 1; // (int) cast to avoid "tautological compare warning"
  }
  return ErrorStrings[err];
}
