#ifdef PHIST_HAVE_MPI
#include <mpi.h>
#endif

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

#include "phist_macros.h"
#include "phist_enums.h"
#include "phist_kernels.h"
#include "phist_operator.h"
#include "phist_jdqr.h"
#include ${PHIST_TG_HFILE}
#include "phist_driver_utils.h"

// JDQR reads an input matrix and tries to compute a given number of            
// exterior eigenpairs at either end of the spectrum. Input parameters          
// are (in this order on the command line)                                      
//                                                                              
// <matrix file name> :  a .mm or .bin file (matrix market or ghost binary CRS) 
// <num eigs>         : number of desired eigenpairs [10]                       
// <which>            : can be "LM", "SM", "LR" or "SR" (Largest/Smallest       
//                      Magnitude/Real part) ["LM"]                             
// <tol>              : convergence tolerance [1.0e-10]                         
// <max iters>        : maximum number of iterations allowed [250]              
// <minBas>           : number of vectors to keep in the basis upon restart [10]
// <maxBas>           : number of vectors to generate before restarting         
//                      [minBas+20]                                             
int main(int argc, char** argv)
  {
  int rank, num_proc;
  int i, ierr;
  int verbose;

  comm_ptr_t comm;
  crsMat_ptr_t A;
  op_ptr_t A_op; // this is a wrapper for the CRS matrix which we pass to the actual solver
  op_ptr_t B_op=NULL; // no mass matrix up to now
  
  const_map_ptr_t map; // map (element distribution) of vectors according to 
                       // the distribution of matrix rows
  mvec_ptr_t X; // multivector for getting the eigenvectors
  
  ST* evals; // for real non-symmetric matrices we can get complex pairs,
             // so we need twice the amount of memory to store the eigenvalues 
  MT* resid;
  
  int* is_cmplx=NULL; // only required for the real case for indicating complex EV

  eigSort_t which;
  MT tol;
  char* filename;
  
  int num_eigs,num_iters,max_iters;
  int minBas,maxBas; /* whenever maxBas vectors have been created, we shrink the search space to minBas */
  
  PHIST_ICHK_IERR(phist_kernels_init(&argc,&argv,&ierr),ierr);

  PHIST_ICHK_IERR(phist_comm_create(&comm,&ierr),ierr);

  PHIST_ICHK_IERR(phist_comm_get_rank(comm, &rank,&ierr),ierr);
  PHIST_ICHK_IERR(phist_comm_get_size(comm, &num_proc,&ierr),ierr);

  verbose= (rank==0);

#ifdef TESTING
  std::srand(49+rank);
#endif

  if (argc<2)
    {
    if (verbose) fprintf(stdout,"Usage: ./Xjdqr <matrix filename> [<num eigs>] [<which>] [<tol>] [<max iters> <min basis> <max basis>]\n");
    return 1;
    }

  filename = argv[1];
  
  if (argc<3)
    {
    num_eigs=10;
    }
  else
    {
    num_eigs=atoi(argv[2]);
    }

  if (argc<4)
    {
    which=LM;
    }
  else
    {
    if (!strcmp(argv[3],"LM")) which=LM;
    else if (!strcmp(argv[3],"SM")) which=SM;
    else if (!strcmp(argv[3],"LR")) which=LR;
    else if (!strcmp(argv[3],"SR")) which=SR;
    else
      {
      if (verbose) 
        {
        fprintf(stderr,"ERROR: the which parameter may be \"LM\",\"SM\",\"LR\" or \"SR\".\n");
        fprintf(stderr,"       run the program without args to get a usage message.\n");
        }
      return -1;
      }
    }
    
  if (argc<5)
    {
    tol=1.0e-10;
    }
  else
    {
    tol=(MT)atof(argv[4]);
    }

  if (argc<6)
    {
    max_iters=250;
    }
  else
    {
    max_iters=atoi(argv[5]);
    }

  if (argc<7)
    {
    minBas=10;
    }
  else
    {
    minBas=atoi(argv[6]);
    }

  if (argc<8)
    {
    maxBas=minBas+20;
    }
  else
    {
    maxBas=atoi(argv[7]);
    }

  PHIST_ICHK_IERR(SUBR(crsMat_read)(&A,filename,&ierr),ierr);
  
  PHIST_ICHK_IERR(SUBR(crsMat_get_domain_map)(A, &map,&ierr),ierr);

  PHIST_ICHK_IERR(SUBR(mvec_create)(&X,map,num_eigs+1,&ierr),ierr);
//  PHIST_ICHK_IERR(SUBR(mvec_random)(X,&ierr),ierr);
  PHIST_ICHK_IERR(SUBR(mvec_put_value)(X,ONE,&ierr),ierr);
  
  num_iters=max_iters;
  // create operator wrapper for computing Y=A*X using a CRS matrix
  A_op = (op_ptr_t)malloc(sizeof(TYPE(op)));
  PHIST_ICHK_IERR(SUBR(op_wrap_crsMat)(A_op,A,&ierr),ierr);
  
  // allocate memory for eigenvalues and residuals. We allocate
  // one extra entry because in the real case we may get that the
  // last EV to converge is a complex pair (requirement of JDQR)
  evals = (ST*)malloc((num_eigs+1)*sizeof(ST));
  resid = (MT*)malloc((num_eigs+1)*sizeof(MT));
  is_cmplx = (int*)malloc((num_eigs+1)*sizeof(int));

  // first column in X is currently used as starting vector of Arnoldi in jdqr. The first 
  // jmin vectors are constructed by an Arnoldi process for stability reasons.
  int nloc,lda; 
  ST* valX0;
  MT nrmX0[num_eigs+1];
  PHIST_ICHK_IERR(SUBR(mvec_my_length)(X,&nloc,&ierr),ierr);
  PHIST_ICHK_IERR(SUBR(mvec_extract_view)(X,&valX0,&lda,&ierr),ierr);
  PHIST_ICHK_IERR(SUBR(mvec_normalize)(X,nrmX0,&ierr),ierr);

  SUBR(jdqr)(A_op,B_op,X,evals,resid,is_cmplx, 
        which, tol,
        &num_eigs,&num_iters,
        minBas, maxBas,
        &ierr);

  if (ierr!=0)
    {
    if (verbose) fprintf(stdout,"code %d returned from jdqr\n",ierr);
    if (ierr<0) return ierr;
    }
  if (verbose)
    {
    fprintf(stdout,"Found %d eigenpairs after %d iterations\n",num_eigs,num_iters);
    }

  MT expRes[MIN(num_eigs,1)];

  if (num_eigs>0)
    {
    // compute residuals explicitly
    TYPE(mvec_ptr) R=NULL,Xv=NULL;
    PHIST_ICHK_IERR(SUBR(mvec_create)(&R,map,num_eigs,&ierr),ierr);
    PHIST_ICHK_IERR(SUBR(mvec_view_block)(X,&Xv,0,num_eigs-1,&ierr),ierr);
    PHIST_ICHK_IERR(SUBR(crsMat_times_mvec)(ONE,A,Xv,ZERO,R,&ierr),ierr);
#ifdef IS_COMPLEX
    PHIST_ICHK_IERR(SUBR(mvec_vadd_mvec)(evals,Xv,-ONE,R,&ierr),ierr);
#else
    // we have complex pairs as [v_r, v_i] and [lambda_r, lambda_i] right now.
    // To get the residual correct, create the block diagonal matrix D with   
    // D_j=[lambda_r, lambda_i; -lambda_i, lambda_r] for complex pairs and    
    // then compute A*X-X*D as the residual
    TYPE(sdMat_ptr) D=NULL;
    PHIST_ICHK_IERR(SUBR(sdMat_create)(&D,num_eigs,num_eigs,comm,&ierr),ierr);
    PHIST_ICHK_IERR(SUBR(sdMat_put_value)(D,ZERO,&ierr),ierr);
    ST *D_raw=NULL;
    lidx_t ldD;
    PHIST_ICHK_IERR(SUBR(sdMat_extract_view)(D,&D_raw,&ldD,&ierr),ierr);
    i=0;
    while (i<num_eigs)
      {
      D_raw[i*ldD+i]= evals[i];
      if (is_cmplx[i])
        {
        D_raw[(i+1)*ldD+(i+1)]=evals[i];
        D_raw[i*ldD+(i+1)]=-evals[i+1];
        D_raw[(i+1)*ldD+i]=-evals[i+1];
        i++;
        }
      i++;
      }
    PHIST_ICHK_IERR(SUBR(mvec_times_sdMat)(ONE,Xv,D,-ONE,R,&ierr),ierr);
    PHIST_ICHK_IERR(SUBR(sdMat_delete)(D,&ierr),ierr);
#endif
    PHIST_ICHK_IERR(SUBR(mvec_norm2)(R,expRes,&ierr),ierr);
    PHIST_ICHK_IERR(SUBR(mvec_delete)(Xv,&ierr),ierr);
    PHIST_ICHK_IERR(SUBR(mvec_delete)(R,&ierr),ierr);
    }

  if (verbose && num_eigs>0)
    {
    fprintf(stdout,"  Eigenvalue\t\t\t\t\t\tRitz Residual\tExpl. Residual\n");
    fprintf(stdout,"======================================================================================\n");
    int i=0;
    while (i<num_eigs)
      {
#ifdef IS_COMPLEX
      fprintf(stdout,"%24.16e%+24.16ei\t%3.1e\t\t%3.1e\n",
        REAL(evals[i]),IMAG(evals[i]),resid[i],expRes[i]);
#else
      if (is_cmplx[i])
        {
        fprintf(stdout,"%24.16e%+24.16ei\t%3.1e\t\t%3.1e\n",evals[i],evals[i+1],resid[i],expRes[i]);
        fprintf(stdout,"%24.16e%+24.16ei\t%3.1e\t\t%3.1e\n",evals[i],-evals[i+1],resid[i+1],expRes[i+1]);
        i++;
        }
      else
        {
        fprintf(stdout,"%24.16e\t\t\t\t%3.1e\t\t%3.1e\n",evals[i],resid[i],expRes[i]);
        }
#endif
      i++;
      }
    }

  free(evals);
  free(resid);
  free(is_cmplx);
  
  PHIST_ICHK_IERR(SUBR(crsMat_delete)(A,&ierr),ierr);
  PHIST_ICHK_IERR(SUBR(mvec_delete)(X,&ierr),ierr);
  free(A_op);
  PHIST_ICHK_IERR(phist_kernels_finalize(&ierr),ierr);
  return ierr;
  }
