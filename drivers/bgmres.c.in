#ifdef PHIST_HAVE_MPI
#include <mpi.h>
#endif

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

#include "phist_macros.h"
#include "phist_kernels.h"
#include "phist_operator.h"
#include "phist_bgmres.h"
#include ${PHIST_TG_HFILE}

#include "phist_driver_utils.h"

int main(int argc, char** argv)
  {
  int rank, num_proc;
  int i, ierr;
  bool verbose;

  comm_ptr_t comm;
  crsMat_ptr_t A;
  op_ptr_t A_op; // this is a wrapper for the CRS matrix which we pass to the actual solver
  
  const_map_ptr_t map; // map (element distribution) of vectors according to 
                       // the distribution of matrix rows
  mvec_ptr_t X,XEX,B,R;// multivectors for solution and rhs (XEX exact solution to compare)
  
  MT tol;
  MT *rnorm2; /* for computing the residual norm axplicitly */
  MT *norm2; /* for computing the error norms after the solve */
  MT *xnorm2, *bnorm2; /* for scaling, norm of exact solution and rhs */
  char* filename;
  
  int num_iters;
  int max_iters,max_blocks,num_rhs;
  int variant=0; // only proper block GMRES accessible via this driver right now.
  
  PHIST_ICHK_IERR(phist_kernels_init(&argc,&argv,&ierr),ierr);

  PHIST_ICHK_IERR(phist_comm_create(&comm,&ierr),ierr);

  PHIST_ICHK_IERR(phist_comm_get_rank(comm, &rank,&ierr),ierr);
  PHIST_ICHK_IERR(phist_comm_get_size(comm, &num_proc,&ierr),ierr);

  verbose= (rank==0);

  if (argc<2)
    {
    if (verbose) fprintf(stdout,"Usage: ./Xbgmres <matrix market filename> [<max iters> [<tol> [<num rhs> [<max blocks>]]]]\n");
    return 1;
    }

  filename = argv[1];
  
  if (argc<3)
    {
    max_iters=300;
    }
  else
    {
    max_iters=atoi(argv[2]);
    }

  if (argc<4)
    {
    tol=1.0e-6;
    }
  else
    {
    tol=(MT)atof(argv[3]);
    }

  if (argc<5)
    {
    num_rhs=1;
    }
  else
    {
    num_rhs=atoi(argv[4]);
    }

  if (argc<6)
    {
    max_blocks=30;
    }
  else
    {
    max_blocks=atoi(argv[5]);
    }

  if (verbose) 
    {
    PHIST_OUT(0,"matrix file: %s\n",filename);
    PHIST_OUT(0,"number of rhs: %d\n",num_rhs);
    }  

  PHIST_ICHK_IERR(SUBR(crsMat_read)(&A,filename,&ierr),ierr);
  
  /* we assume domain map = range map here, which is reasonable for something
     you want to put into a linear solver */
  PHIST_ICHK_IERR(SUBR(crsMat_get_domain_map)(A, &map,&ierr),ierr);

  /* create vectors */
  PHIST_ICHK_IERR(SUBR(mvec_create)(&XEX,map,num_rhs,&ierr),ierr);
  PHIST_ICHK_IERR(SUBR(mvec_create)(&X,map,num_rhs,&ierr),ierr);
  PHIST_ICHK_IERR(SUBR(mvec_create)(&B,map,num_rhs,&ierr),ierr);
  PHIST_ICHK_IERR(SUBR(mvec_create)(&R,map,num_rhs,&ierr),ierr);
  
  /* randomize the solution vector */
  PHIST_ICHK_IERR(SUBR(mvec_put_value)(X,ZERO,&ierr),ierr);
  //TROET
  //PHIST_ICHK_IERR(SUBR(mvec_random)(XEX,&ierr),ierr);
  PHIST_ICHK_IERR(SUBR(mvec_put_value)(XEX,ONE,&ierr),ierr);
  
  /* compute rhs B=A*XEX */
  PHIST_ICHK_IERR(SUBR(crsMat_times_mvec)(ONE,A,XEX,ZERO,B,&ierr),ierr);
  
  /* create operator wrapper for computing Y=A*X using a CRS matrix */
  A_op = (op_ptr_t)malloc(sizeof(TYPE(op)));
  PHIST_ICHK_IERR(SUBR(op_wrap_crsMat)(A_op,A,&ierr),ierr);
  
  num_iters=max_iters;
  
  SUBR(bgmres)(A_op,X,B,tol,&num_iters,max_blocks,variant,NULL,&ierr);

  if (ierr!=0)
    {
    if (verbose) fprintf(stdout,"code %d returned from Belos BlockGMRES\n",ierr);
    if (ierr<0) return ierr;
    }
  
  PHIST_OUT(1,"number of iterations performed: %d\n",num_iters);
  
  /* compute residual norms */
  PHIST_ICHK_IERR(SUBR(crsMat_times_mvec)(ONE,A,X,ZERO,R,&ierr),ierr);
  PHIST_ICHK_IERR(SUBR(mvec_add_mvec)(-ONE,B,ONE,R,&ierr),ierr);
  
  /* compute ||X - XEX||_2 */
  norm2=(MT*)malloc(num_rhs*sizeof(MT));
  rnorm2=(MT*)malloc(num_rhs*sizeof(MT));
  xnorm2=(MT*)malloc(num_rhs*sizeof(MT));
  bnorm2=(MT*)malloc(num_rhs*sizeof(MT));
  PHIST_ICHK_IERR(SUBR(mvec_add_mvec)(ONE,XEX,-ONE,X,&ierr),ierr);

  PHIST_ICHK_IERR(SUBR(mvec_norm2)(R,rnorm2,&ierr),ierr);
  PHIST_ICHK_IERR(SUBR(mvec_norm2)(X,norm2,&ierr),ierr);
  PHIST_ICHK_IERR(SUBR(mvec_norm2)(XEX,xnorm2,&ierr),ierr);
  PHIST_ICHK_IERR(SUBR(mvec_norm2)(B,bnorm2,&ierr),ierr);
  
  if (verbose)
    {
    fprintf(stdout,"residual 2-norms: ||r||, ||r||/||x||, ||r||/||b||:\n");
    for (i=0;i<num_rhs;i++)
      {
      fprintf(stdout,"%8.4e\t%8.4e\t%8.4e",rnorm2[i],rnorm2[i]/xnorm2[i],rnorm2[i]/bnorm2[i]);
      }
    fprintf(stdout,"\n");

    fprintf(stdout,"error 2-norms: ||e||, ||e||/||x||, ||e||/||b||:\n");
    for (i=0;i<num_rhs;i++)
      {
      fprintf(stdout,"%8.4e\t%8.4e\t%8.4e",norm2[i],norm2[i]/xnorm2[i],norm2[i]/bnorm2[i]);
      }
    fprintf(stdout,"\n");
    }
  
  free(rnorm2);
  free(norm2);
  free(xnorm2);
  free(bnorm2);
  
  PHIST_ICHK_IERR(SUBR(crsMat_delete)(A,&ierr),ierr);
  PHIST_ICHK_IERR(SUBR(mvec_delete)(X,&ierr),ierr);
  PHIST_ICHK_IERR(SUBR(mvec_delete)(XEX,&ierr),ierr);
  PHIST_ICHK_IERR(SUBR(mvec_delete)(B,&ierr),ierr);
  PHIST_ICHK_IERR(SUBR(mvec_delete)(R,&ierr),ierr);
  free(A_op);
  PHIST_ICHK_IERR(phist_kernels_finalize(&ierr),ierr);
  return ierr;
  }
