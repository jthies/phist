#include "phist_config.h"

#ifdef PHIST_HAVE_MPI
#include <mpi.h>
#endif

#include "phist_macros.h"
#include "phist_get_arg.hpp"
#include "phist_kernels.h"
#include "phist_operator.h"
#include "phist_anasazi.h"
#include ${PHIST_TG_HFILE}

#include "phist_driver_utils.h"
#include "phist_ScalarTraits.hpp"

int main(int argc, char** argv)
  {
#include "phist_std_typedefs.hpp"
  int i, ierr;

  comm_ptr_t comm;
  crsMat_ptr_t A;
  op_ptr_t A_op, B_op; // this is a wrapper for the CRS matrix which we pass to the actual solver
  
  const_map_ptr_t map; // map (element distribution) of vectors according to 
                       // the distribution of matrix rows
  mvec_ptr_t X,R;// multivectors for eigenvectors and residuals

  char* matname;
    
  // default input parameters:
  MT tol=1.0e-6;
  eigSort_t which=LM;
  
  int sym=0;
  int how_many=10;
  int max_iters=300;
  int block_size=1;
  int num_blocks=20;

  int variant=0; // only block Krylov-Schur accessible via this driver right now.
  
  PHIST_ICHK_IERR(phist_kernels_init(&argc,&argv,&ierr),ierr);

PHIST_MAIN_TASK_BEGIN

  PHIST_ICHK_IERR(phist_comm_create(&comm,&ierr),ierr);

  if (argc<2)
  {
    PHIST_SOUT(PHIST_ERROR,"Usage: %s <matrix A> <symmetric/hermitian> <how many> <which> <tol>\n"
                           "          <max iters> <block size> <num blocks>\n"
                           "(all but the first argument get default values if omitted)\n", 
                           argv[0]);
    // print usage message for creating/reading a matrix
    SUBR(create_matrix)(NULL, NULL, "usage",&ierr);

    return 1;
  }

  matname = argv[1];
  
  int p=2;
  GET_ARG(sym,p++);
  GET_ARG(how_many,p++);
  GET_ARG(which,p++);
  GET_ARG(tol,p++);
  GET_ARG(max_iters,p++);
  GET_ARG(block_size,p++);
  GET_ARG(num_blocks,p++);

  PHIST_ICHK_IERR(SUBR(create_matrix)(&A,comm,matname,&ierr),ierr);
  
  /* we assume domain map = range map here, which is reasonable for something
     you want to put into a linear solver */
  PHIST_ICHK_IERR(SUBR(crsMat_get_domain_map)(A, &map,&ierr),ierr);

  /* create vectors */
  PHIST_ICHK_IERR(SUBR(mvec_create)(&X,map,how_many,&ierr),ierr);
  PHIST_ICHK_IERR(SUBR(mvec_create)(&R,map,how_many,&ierr),ierr);
  
  /* create operator wrapper for computing Y=A*X using a CRS matrix */
  A_op = new TYPE(op);
  B_op = NULL;
  PHIST_ICHK_IERR(SUBR(op_wrap_crsMat)(A_op,A,&ierr),ierr);

  MT resid[how_many];
  ST eigs[how_many];
  MT expRes[how_many];
  int num_iters=max_iters;

  SUBR(anasazi)(A_op,B_op,NULL,which,tol,&how_many,
        &num_iters,block_size,num_blocks,
        sym,X,eigs,resid,&ierr);

  if (ierr!=0)
    {
    PHIST_SOUT(PHIST_WARNING,"code %d returned from Belos BlockGMRES\n",ierr);
    if (ierr<0) return ierr;
    }
  PHIST_OUT(1,"number of iterations performed: %d\n",num_iters);
  PHIST_OUT(1,"number of eigenpairs computed: %d\n",how_many);

  /* compute residual norms */
  PHIST_ICHK_IERR(SUBR(crsMat_times_mvec)(st::one(),A,X,st::zero(),R,&ierr),ierr);
  PHIST_ICHK_IERR(SUBR(mvec_vadd_mvec)(eigs,X,-st::one(),R,&ierr),ierr);
  
  PHIST_ICHK_IERR(SUBR(mvec_norm2)(R,expRes,&ierr),ierr);
  
  PHIST_SOUT(PHIST_VERBOSE,"Ritz value\timp. res\texp. res\n");
  for (i=0;i<how_many;i++)
  {
    PHIST_SOUT(PHIST_VERBOSE,"%8.4e\t%8.4e\t%8.4e",st::real(eigs[i]),resid[i],expRes[i]);
  }
    
  PHIST_ICHK_IERR(SUBR(crsMat_delete)(A,&ierr),ierr);
  PHIST_ICHK_IERR(SUBR(mvec_delete)(X,&ierr),ierr);
  PHIST_ICHK_IERR(SUBR(mvec_delete)(R,&ierr),ierr);
  free(A_op);

PHIST_MAIN_TASK_END

  PHIST_ICHK_IERR(phist_kernels_finalize(&ierr),ierr);
  return ierr;
  }
