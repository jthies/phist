#include "phist_config.h"

#ifdef PHIST_HAVE_MPI
#include <mpi.h>
#endif

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <strings.h>

#include "phist_get_arg.hpp"

#include "phist_macros.h"
#include "phist_kernels.h"
#include "phist_operator.h"
#include "phist_precon.h"
#include "phist_belos.h"

#include "phist_blockedgmres.h"
#include "phist_precon.h"


#include ${PHIST_TG_HFILE}

#include "phist_driver_utils.h"
#include "phist_ScalarTraits.hpp"
#include "phist_std_typedefs.hpp"

int main(int argc, char** argv)
{
  int rank, num_proc;
  int i, iflag;
  int useIMGS=0;

  phist_comm_ptr comm;
  sparseMat_ptr A;
  linearOp_ptr A_op; // this is a wrapper for the CRS matrix which we pass to the actual solver
  linearOp_ptr P_op=NULL; // preconditioner. NULL means identity/no preconditioning
  
  phist_const_map_ptr map; // map (element distribution) of vectors according to 
                       // the distribution of matrix rows
  mvec_ptr X,XEX,B,R;// multivectors for solution and rhs (XEX exact solution to compare)
  
  MT *rnorm2; /* for computing the residual norm axplicitly */
  MT *norm2; /* for computing the error norms after the solve */
  MT *xnorm2, *bnorm2; /* for scaling, norm of exact solution and rhs */
  char* matname;
  
  int num_iters, nconv;

  PHIST_ICHK_IERR(phist_kernels_init(&argc,&argv,&iflag),iflag);

  PHIST_ICHK_IERR(phist_comm_create(&comm,&iflag),iflag);

  PHIST_ICHK_IERR(phist_comm_get_rank(comm, &rank,&iflag),iflag);
  PHIST_ICHK_IERR(phist_comm_get_size(comm, &num_proc,&iflag),iflag);

  if (argc<2)
  {
    PHIST_SOUT(PHIST_VERBOSE,"Usage: %s <matrix> [<max iters> [<tol> [<num rhs> [<max blocks> [<precon> [<prec_opts>]>]]]]]\n",argv[0]);
    SUBR(create_matrix)(NULL,NULL,"usage",&iflag);
    SUBR(precon_create)(NULL,NULL,st::zero(),NULL,NULL,NULL,"usage",NULL,&iflag);
    return 1;
  }

  matname = argv[1];
  
  int p=2;

  int max_iters=300;  
  GET_ARG(max_iters,p++,max_iters>0);
  MT tol=1e-6;
  GET_ARG(tol,p++,tol>0&&tol<1);
  int num_rhs=1;
  GET_ARG(num_rhs,p++,num_rhs>0);
  if (num_rhs>1)
  {
    // basic mechanism is there but it's not working yet
    PHIST_SOUT(PHIST_ERROR,"case num_rhs>1 is not correctly implemented in %s\n",__FILE__);
    return -1;
  }
  int max_blocks=std::min(30,max_iters);
  GET_ARG(max_blocks,p++,max_blocks<=max_iters);
  const char* prec_type="None";
  GET_ARG(prec_type,p++,str2precon(prec_type)!=phist_INVALID_PRECON);
  const char* prec_opts="";
  GET_ARG(prec_opts,p++,true);

  // if many RHS are given it may be better to use a block size of 4 or 8, but
  // this is not implemented here. The blockedGMRES implementation is in principle
  // capable of doing that, of course. 
  int block_size=num_rhs>4?4:num_rhs;


  PHIST_OUT(PHIST_INFO,"matrix: %s\n",matname);
  PHIST_OUT(PHIST_INFO,"number of rhs: %d\n",num_rhs);
  PHIST_OUT(PHIST_INFO,"preconditioner: %s\n",prec_type);
  PHIST_OUT(PHIST_INFO,"prec options: %s\n",prec_opts);

  //iflag=PHIST_SPARSEMAT_PERM_GLOBAL;
  PHIST_ICHK_IERR(SUBR(create_matrix)(&A,comm,matname,&iflag),iflag);
  
  /* we assume domain map = range map here, which is reasonable for something
     you want to put into a linear solver */
  PHIST_ICHK_IERR(SUBR(sparseMat_get_domain_map)(A, &map,&iflag),iflag);

  /* create vectors */
  PHIST_ICHK_IERR(SUBR(mvec_create)(&XEX,map,num_rhs,&iflag),iflag);
  PHIST_ICHK_IERR(SUBR(mvec_create)(&X,map,num_rhs,&iflag),iflag);
  PHIST_ICHK_IERR(SUBR(mvec_create)(&B,map,num_rhs,&iflag),iflag);
  PHIST_ICHK_IERR(SUBR(mvec_create)(&R,map,num_rhs,&iflag),iflag);
  
  /* randomize the solution vector */
  PHIST_ICHK_IERR(SUBR(mvec_put_value)(X,st::zero(),&iflag),iflag);
  //PHIST_ICHK_IERR(SUBR(mvec_random)(XEX,&iflag),iflag);
  PHIST_ICHK_IERR(SUBR(mvec_put_value)(XEX,st::one(),&iflag),iflag);
  
  /* compute rhs B=A*XEX */
  PHIST_ICHK_IERR(SUBR(sparseMat_times_mvec)(st::one(),A,XEX,st::zero(),B,&iflag),iflag);
  
  /* create operator wrapper for computing Y=A*X using a CRS matrix */
  A_op = (linearOp_ptr)malloc(sizeof(TYPE(linearOp)));
  PHIST_ICHK_IERR(SUBR(linearOp_wrap_sparseMat)(A_op,A,&iflag),iflag);
  
  /* create the preconditioner */
  if (strcasecmp(prec_type,"None")!=0)
  {
    P_op = (linearOp_ptr)malloc(sizeof(TYPE(linearOp)));
    PHIST_SOUT(PHIST_VERBOSE,"compute preconditioner '%s'\n",prec_type);
    PHIST_ENTER_FCN("main: preconditioner setup");
    PHIST_ICHK_IERR(SUBR(precon_create)(P_op,A,st::zero(),NULL,NULL,NULL,prec_type,prec_opts,&iflag),iflag);
  }

  TYPE(blockedGMRESstate_ptr) states[block_size];
    PHIST_ICHK_IERR(SUBR(blockedGMRESstates_create)(states, block_size, map, max_blocks, &iflag), iflag);

  for (int i=0; i<block_size; i++) states[i]->tol=tol;

  int num_converged=0;
  int num_failed=0;
  int status[num_rhs];
  int total_iter[num_rhs];
  int active_cols[block_size];
  
  for (int i=0; i<num_rhs; i++) 
  {
    status[i]=-2; // not started
    total_iter[i]=0;
  }
  for (int i=0; i<block_size; i++) active_cols[i]=-1;
  
  // for copying around single columns we may need a view object, whenever it is updated
  // its memory is freed, and after the loop we delete it explicitly
  TYPE(mvec_ptr) x_i=NULL;

  while (num_converged+num_failed<num_rhs)
  {
    
    // first setup at most block_size systems at a time to work on,
    // skipping any that have converged or failed (exceeded max_iters)

    TYPE(mvec_ptr) b_i=NULL;
    
    int num_active=0;
    for (int i=0; i<num_rhs; i++)
    {
      if (status[i]==0||status[i]==3) continue; // converged (0 r failed (3)
      if (status[i]==1||status[i]==2) {num_active++; continue;}// still busy

      if (num_active==block_size) break;

      // find first "free" state object
      int pos=0;
      while ( pos<=block_size && states[pos]->status>0 && states[pos]->status!=3) pos++;
      if (pos==block_size) break; // everyone is still busy

      // system i needs to be worked on, and states[num_active] is free to do it
      status[i]=1;

      PHIST_ICHK_IERR(SUBR(mvec_view_block)(B,&b_i,i,i,&iflag),iflag);
      // reset selected state object with 0 initial guess
      PHIST_ICHK_IERR(SUBR(blockedGMRESstate_reset)(states[pos], b_i, NULL, &iflag), iflag);
      active_cols[pos]=i;
      num_active++;
    }

    if (b_i) PHIST_ICHK_IERR(SUBR(mvec_delete)(b_i,&iflag),iflag);

    if (num_active==0) break;
        
    // perform restarts if needed
    for (int i=0; i<num_active; i++)
    {
      if (states[i]->status==2)
      {
        int id=active_cols[i];
        PHIST_SOUT(PHIST_VERBOSE,"restart system %d (state %d)\n",id,i);
        PHIST_ICHK_IERR(SUBR(mvec_view_block)(X,&x_i,id,id,&iflag),iflag);
#if 0
        TYPE(mvec_ptr) resid=NULL;
        PHIST_ICHK_IERR(SUBR(mvec_create)(&resid,map,1,&iflag),iflag);
        PHIST_ICHK_IERR(SUBR(mvec_get_block)(B,resid,id,id,&iflag),iflag);
        PHIST_ICHK_IERR(SUBR(sparseMat_times_mvec)(st::one(),A,x_i,-st::one(),resid,&iflag),iflag);
        MT rnorm;
        PHIST_ICHK_IERR(SUBR(mvec_norm2)(resid,&rnorm,&iflag),iflag);
        PHIST_SOUT(PHIST_VERBOSE,"res norm of restart vector: %e\n",rnorm);
#endif
        PHIST_ICHK_IERR(SUBR(blockedGMRESstate_reset)(states[i], NULL, x_i, &iflag), iflag);
      }
    }
    
    if (num_active>0)
    {
      PHIST_SOUT(PHIST_VERBOSE," working on %d systems: ",num_active);
      for (int i=0;i<num_active;i++) PHIST_SOUT(PHIST_VERBOSE,"%d ",active_cols[i]);
      PHIST_SOUT(PHIST_VERBOSE,"\n");
    }

    int nIter=max_iters;
    PHIST_ICHK_NEG_IERR(SUBR(blockedGMRESstates_iterate)(A_op, P_op,states, num_active, &nIter, useIMGS, &iflag), iflag);
    for (int i=0; i<num_active; i++) 
    {
      status[active_cols[i]]=states[i]->status;
      total_iter[active_cols[i]]=states[i]->totalIter;
    }
    // we need to update the solution for any systems that
    // - have converged (status 0)
    // - need a restart (status 1)
    // - have failed (status 2)
    int num_updates=0;
    TYPE(blockedGMRESstate_ptr) update_states[num_active];
    int update_cols[num_active];
    for (int i=0; i<num_active; i++)
    {
      if (states[i]->status==0)
      {
        num_converged++;
      }
      else if (states[i]->status==3) 
      {
        num_failed++;
      }
      // update solution for systems that are converged (0), need a restart (2) or have failed (3)
      if (states[i]->status==0||states[i]->status>=2)
      {
        update_cols[num_updates]=active_cols[i];
        update_states[num_updates]=states[i];
        num_updates++;
      }
    }
    if (num_updates>0)
    {
      PHIST_SOUT(PHIST_VERBOSE,"update systems: ");
      for (int i=0; i<num_updates; i++) PHIST_SOUT(PHIST_VERBOSE," %d",update_cols[i]);
      PHIST_SOUT(PHIST_VERBOSE,"\n");
      // if we're updating a contiguous block of columns, use a view.
      // Otherwise copy the columns to make them continuguous
      bool contig=true;
      for (int i=1; i<num_updates; i++) contig&=(update_cols[i]==update_cols[i-1]+1);
      _MT_ res_norms[num_updates];
      TYPE(mvec_ptr) x=NULL;
      if (contig)
      {
        PHIST_ICHK_IERR(SUBR(mvec_view_block)(X,&x,update_cols[0],update_cols[num_updates-1],&iflag),iflag);
      }
      else
      {
        PHIST_ICHK_IERR(SUBR(mvec_create)(&x,map,num_updates,&iflag),iflag);
        for (int i=0; i<num_updates; i++)
        {
          PHIST_ICHK_IERR(SUBR(mvec_view_block)(X,&x_i,update_cols[i],update_cols[i],&iflag),iflag);
          PHIST_ICHK_IERR(SUBR(mvec_set_block)(x,x_i,i,i,&iflag),iflag);
        }
      }    
      PHIST_ICHK_IERR(SUBR(blockedGMRESstates_updateSol)(update_states,num_updates,P_op,x,res_norms,false,&iflag),iflag);
      if (!contig) // need to copy back solution
      {
        for (int i=0; i<num_updates; i++)
        {
          PHIST_ICHK_IERR(SUBR(mvec_view_block)(x,&x_i,i,i,&iflag),iflag);
          PHIST_ICHK_IERR(SUBR(mvec_set_block)(X,x_i,update_cols[i],update_cols[i],&iflag),iflag);
        }
      }
      PHIST_ICHK_IERR(SUBR(mvec_delete)(x,&iflag),iflag);
    }
    for (int i=0; i<num_active; i++)
    {
      if (status[active_cols[i]]!=1&&status[active_cols[i]]!=2)
      {
        // state object is free again
        PHIST_SOUT(PHIST_VERBOSE,"state[%d] free to use again after working on system %d\n",i,active_cols[i]);
        PHIST_ICHK_IERR(SUBR(blockedGMRESstate_reset)(states[i],NULL,NULL,&iflag),iflag);        
      }
    }
  }

  // delete view of single column if it was used
  if (x_i) PHIST_ICHK_IERR(SUBR(mvec_delete)(x_i,&iflag),iflag);
  
  /* compute residual norms */
  PHIST_ICHK_IERR(SUBR(sparseMat_times_mvec)(st::one(),A,X,st::zero(),R,&iflag),iflag);
  PHIST_ICHK_IERR(SUBR(mvec_add_mvec)(-st::one(),B,st::one(),R,&iflag),iflag);
  
  /* compute ||X - XEX||_2 */
  norm2=new MT[num_rhs];
  rnorm2=new MT[num_rhs];
  xnorm2=new MT[num_rhs];
  bnorm2=new MT[num_rhs];;
  PHIST_ICHK_IERR(SUBR(mvec_add_mvec)(st::one(),XEX,-st::one(),X,&iflag),iflag);

  PHIST_ICHK_IERR(SUBR(mvec_norm2)(R,rnorm2,&iflag),iflag);
  PHIST_ICHK_IERR(SUBR(mvec_norm2)(X,norm2,&iflag),iflag);
  PHIST_ICHK_IERR(SUBR(mvec_norm2)(XEX,xnorm2,&iflag),iflag);
  PHIST_ICHK_IERR(SUBR(mvec_norm2)(B,bnorm2,&iflag),iflag);
  
  PHIST_SOUT(PHIST_INFO,"Total number of iterations:\n:");
  for (int i=0; i<num_rhs; i++)
  {
    PHIST_SOUT(PHIST_INFO,"SYSTEM %d: %d (%s)\n",i,total_iter[i],total_iter[i]<max_iters?"SUCCESS":"FAILURE");
  }
  
  PHIST_SOUT(PHIST_VERBOSE,"residual 2-norms: ||r||, ||r||/||x||, ||r||/||b||:\n");
  for (i=0;i<num_rhs;i++)
  {
    PHIST_SOUT(PHIST_VERBOSE,"%8.4e\t%8.4e\t%8.4e (%s)\n",rnorm2[i],rnorm2[i]/xnorm2[i],rnorm2[i]/bnorm2[i], 
    rnorm2[i]/bnorm2[i]<tol?"SUCCESS":"FAILURE");
  }
  PHIST_SOUT(PHIST_VERBOSE,"\n");

  PHIST_SOUT(PHIST_VERBOSE,"error 2-norms: ||e||, ||e||/||x||, ||e||/||b||:\n");
  for (i=0;i<num_rhs;i++)
  {
    PHIST_SOUT(PHIST_VERBOSE,"%8.4e\t%8.4e\t%8.4e",norm2[i],norm2[i]/xnorm2[i],norm2[i]/bnorm2[i]);
  }
  PHIST_SOUT(PHIST_VERBOSE,"\n");
  
  
  delete [] rnorm2;
  delete [] norm2;
  delete [] xnorm2;
  delete [] bnorm2;

  // clean up the solver
  PHIST_ICHK_IERR(SUBR(blockedGMRESstates_delete)(states, block_size, &iflag), iflag);


  // since we don't have smart pointers in PHIST, we have to be a bit
  // careful about the order in which we delete stuff. For instance, the
  // preconditioner may have a pointer to A, so we delete it first.
  if (P_op!=NULL)
  {
    PHIST_ICHK_IERR(SUBR(precon_delete)(P_op,&iflag),iflag);
    free(P_op);
  }

  PHIST_ICHK_IERR(SUBR(sparseMat_delete)(A,&iflag),iflag);

  PHIST_ICHK_IERR(SUBR(mvec_delete)(X,&iflag),iflag);
  PHIST_ICHK_IERR(SUBR(mvec_delete)(XEX,&iflag),iflag);
  PHIST_ICHK_IERR(SUBR(mvec_delete)(B,&iflag),iflag);
  PHIST_ICHK_IERR(SUBR(mvec_delete)(R,&iflag),iflag);
  free(A_op);
  PHIST_ICHK_IERR(phist_kernels_finalize(&iflag),iflag);
  return iflag;
}
