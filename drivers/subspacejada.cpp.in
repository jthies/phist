#include "phist_config.h"

#ifdef PHIST_HAVE_MPI
#include <mpi.h>
#endif

#include <string>
#include <sstream>
#include <iostream>

#include "phist_macros.h"
#include "phist_get_arg.hpp"
#include "phist_enums.h"
#include "phist_kernels.h"
#include "phist_operator.h"
#include "phist_jadaOpts.h"
#include "phist_subspacejada.h"
#include ${PHIST_TG_HFILE}
#include "phist_driver_utils.h"


#include "phist_ScalarTraits.hpp"
#include "phist_std_typedefs.hpp"

void SUBR(print_usage)(const char* progname)
{
    int iflag;
    PHIST_SOUT(PHIST_ERROR,"Usage: %s <matrix A> <jadaOpts file>\n",progname);
    
    PHIST_SOUT(PHIST_ERROR,"Alternative (deprecated) Usage: %s <matrix A> [<hermitian>] [<invariant subspace dim>] [<which>] [<tol>] [<max iters> "
    "<JD block size> <min basis> <max basis> <inner block size> <inner iters> <initial shift> <initial shift iters> "
    "<inner solver robust> <inner solver abort when first converged>]\n"
    "\n"
    "Where <matrix A> is a string defining the matrix A (see explanation below)                         \n"
    "      <hermitian> is 0 (general) or 1 (symmetric/hermitian)                                        \n"
    "      <invariant subspace dim> is the number of eigenpairs sought                                  \n"
    "      <which> may be SM, LM, SR, LR (S/L for smallest/largest, M/R for magnitude/real part)        \n"
    "              or of the form \"TARGET\" <value>. SM is equivalent to TARGET 0, in this the driver  \n"
    "              assumes the target lies in the interior of the spectrum and calls the variant with   \n"
    "              harmonic Ritz extraction                                                             \n"
    "      <tol>   convergence tolerance, tol>eps_mach=%e                                               \n"
    "      <max iters>                                                                                  \n"
    "      <JD block size> block size, recommended values are 1 (few eigenvalues), 2 or 4               \n"
    "      <min basis>     JD will restart from this number of vectors, <min basis >= nEig+block_size   \n"
    "      <max basis>     maximum number of basis vectors allowed (including locked eigenvecotors)     \n"
    "      <inner block size> block size for inner linear solver, typically=JD block size               \n"
    "      <inner iters>   max number of linear iterations per outer step, default: 25                  \n"
    "      <initial shift> fix shift for                                                                \n"
    "      <initial shift iters> iterations rather than running an Arnoldi process.                     \n"
    "      <inner solver robust> 0 or 1, 1 is recommended for 'hard' problems, e.g. nonsymmetric ones   \n"
    "      <inner solver abort when first converged> 0/1, 1 is typically a good choice                  \n",
    progname, mt::eps() );
    // print usage message for creating/reading a matrix
    SUBR(create_matrix)(NULL, NULL, "usage",&iflag);
}

int main(int argc, char** argv)
{
  int iflag;
  PHIST_ICHK_IERR(phist_kernels_init(&argc,&argv,&iflag),iflag);

  PHIST_MAIN_TASK_BEGIN

  //------------------------------- parse input parameters ------------------------- 

  // check arguments
  if( argc < 2 )
  {
    SUBR(print_usage)(argv[0]);
    return 1;
  }
  const char* problem=argv[1];

  // fill the jadaOpts struct to pass settings to the solver
  phist_jadaOpts opts;

if (argc==3 && argv[2][0]!='0'&&argv[2][0]!='1')
{
  const char* parameter_file=argv[2];
  PHIST_SOUT(PHIST_VERBOSE,"get options from file '%s'\n",parameter_file);
  PHIST_ICHK_IERR(phist_jadaOpts_fromFile(&opts,parameter_file,&iflag),iflag);
}
else
{

  PHIST_SOUT(PHIST_VERBOSE,"get options from command line (if any)'\n");
  phist_jadaOpts_setDefaults(&opts);
  // parse command line
  int p=2;
  
  // symmetry of A
  bool symmetric=false;
  GET_ARG(symmetric,p++,true);
  opts.symmetry=symmetric?phist_HERMITIAN:phist_GENERAL;
              
  // number of eigenvalues to compute
  GET_ARG(opts.numEigs,p++,opts.numEigs>0);

  // which eigenvalues to compute
  GET_ARG(opts.which,p++,opts.which!=phist_INVALID_EIGSORT&&opts.which!=phist_NO_EIGSORT);

  _ST_ target=st::zero();
  if (opts.which==phist_TARGET)
  {
    opts.which=phist_SM; // use target=0 and harmonic Ritz extraction
    GET_ARG(target,p++,true);
    if (target!=st::zero())
    {
      PHIST_SOUT(PHIST_ERROR,"you requested eigenvalues near a target %8.4e%+8.4ei\n"
                             "while this is easy to implement, we haven't done so yet.\n"
                             "Only the target 0 is allowed for the moment.\n",
                             st::real(target), st::imag(target));
      return PHIST_NOT_IMPLEMENTED;
    }
  }

  // desired accuracy: residuum tolerance
  GET_ARG(opts.convTol,p++,opts.convTol>mt::eps());

  // maximum number of iterations
  GET_ARG(opts.maxIters,p++,opts.maxIters>0);

  // block size
  GET_ARG(opts.blockSize,p++,opts.blockSize>0);

  // min basis size
  GET_ARG(opts.minBas,p++,opts.minBas>=opts.numEigs+opts.blockSize);

  // max basis size
  GET_ARG(opts.maxBas,p++,opts.maxBas>opts.minBas+opts.blockSize&&((opts.maxBas-opts.minBas)%opts.blockSize==0));

  /// we don't allow setting this via the command line, but if you use a parameter file it's no problem
  opts.innerSolvType=symmetric?phist_MINRES:phist_GMRES;
  
  // inner linear solver block size
  GET_ARG(opts.innerSolvBlockSize,p++,opts.innerSolvBlockSize>0&&opts.innerSolvBlockSize<=opts.blockSize);

  // inner GMRES subspace dimension
  GET_ARG(opts.innerSolvMaxBas,p++,opts.innerSolvMaxBas>0);
  opts.innerSolvMaxIters=opts.innerSolvMaxBas;

  // initial shift
  _CT_ initialShift = ct::zero();
  GET_ARG(initialShift,p++,true);
  opts.initialShift_r=ct::real(initialShift);
  opts.initialShift_i=ct::imag(initialShift);

  // number of initial iterations with fixed initial shift
  GET_ARG(opts.initialShiftIters,p++,opts.initialShiftIters>=0);

  // in the inner GMRES: use a iterated modified gram schmidt (more accurate, but quite costly!)
  GET_ARG(opts.innerSolvRobust,p++,true);

  // in the inner GMRES: abort solving a block when first system converged (effectively disables pipelining, but only "blocking" may be faster for now)
  GET_ARG(opts.innerSolvStopAfterFirstConverged,p++,true);

}

  int blockDim=opts.blockSize;
  int nEig=opts.numEigs;

  comm_ptr comm = NULL;
  // wrap MPI_COMM_WORLD
  PHIST_ICHK_IERR(phist_comm_create(&comm,&iflag),iflag);

  //------------------------------- setup matrices and vectors --------------------- 

  // we have gathered all input parameters...
  // read or create matrix A using our helper function from driver_utils,
  // which can handle matrix files like name.mm, name.bin etc. but also our
  // favorite test cases spinSZ<N>, graphene<N> etc.
  sparseMat_ptr A = NULL;
  iflag=PHIST_SPARSEMAT_REPARTITION;
  if( opts.innerSolvBlockSize == 1 )
    iflag = iflag | PHIST_SPARSEMAT_OPT_SINGLESPMVM;
  else
    iflag = iflag | PHIST_SPARSEMAT_OPT_BLOCKSPMVM;
  PHIST_ICHK_IERR(SUBR(create_matrix)(&A,comm,problem,&iflag), iflag);
  
  // create an operator from A
  linearOp_ptr opA = new TYPE(linearOp);
  PHIST_ICHK_IERR(SUBR(linearOp_wrap_sparseMat)(opA,A,&iflag),iflag);

  // we need the domain map of the matrix
  const_map_ptr map = NULL;
  PHIST_ICHK_IERR(SUBR(sparseMat_get_domain_map)(A,&map,&iflag),iflag);

  // setup necessary vectors and matrices for the schur form
  mvec_ptr Q = NULL;
  PHIST_ICHK_IERR(SUBR(mvec_create)(&Q,map,nEig+opts.blockSize-1,&iflag),iflag);
  sdMat_ptr R = NULL;
  PHIST_ICHK_IERR(SUBR(sdMat_create)(&R,nEig+blockDim-1,nEig+blockDim-1,comm,&iflag),iflag);
  _MT_ *resNorm = new _MT_[nEig+blockDim-1];
  _MT_ *resNormExp = new _MT_[nEig+blockDim-1];
  CT *ev = new CT[nEig+blockDim-1];

  // setup start vector (currently to (1 0 1 0 .. ) )
  mvec_ptr v0 = NULL;
  PHIST_ICHK_IERR(SUBR(mvec_create)(&v0,map,1,&iflag),iflag);
//  PHIST_ICHK_IERR(SUBR(mvec_random)(v0,&iflag),iflag);
  PHIST_ICHK_IERR(SUBR(mvec_put_value)(v0,st::one(),&iflag),iflag);
  // initialize random number generator in parallel
/*
  int ilower, iupper;
  PHIST_ICHK_IERR(phist_map_get_ilower(map,&ilower,&iflag),iflag);
  PHIST_ICHK_IERR(phist_map_get_iupper(map,&iupper,&iflag),iflag);
  //std::srand(ilower);
  //PHIST_ICHK_IERR(SUBR(mvec_put_value)(v0,st::zero(),&iflag),iflag);
  _ST_* v0_raw;
  phist_lidx v0_lda;
  PHIST_ICHK_IERR(SUBR(mvec_extract_view)(v0,&v0_raw,&v0_lda,&iflag),iflag);
  for(int i = ilower; i <= iupper; i++)
  {
    _ST_ factor = (i % 2 == 0 ? st::one() : st::zero());
    v0_raw[i-ilower] = factor;
  }
*/


  // used to calculate explicit residuals
  mvec_ptr res;
  PHIST_ICHK_IERR(SUBR(mvec_create)(&res,map,nEig+blockDim-1,&iflag),iflag);

  opts.v0=v0;
  
  int nIter=opts.maxIters;

  //------------------------------- run block JaDa algorithm ----------------------- 
  if (opts.how==phist_HARMONIC)
  {
    PHIST_SOUT(PHIST_INFO,"Jacobi-Davidson for interior eigenvalues\n");
    PHIST_ICHK_IERR(SUBR(harmonicjada)(opA, NULL, opts,
          Q, R, ev, resNorm, &nEig, &nIter, &iflag), iflag);
  }
  else
  {
    PHIST_SOUT(PHIST_INFO,"Jacobi-Davidson for exterior eigenvalues\n");
    PHIST_ICHK_IERR(SUBR(subspacejada)(opA, NULL, opts,
          Q, R, ev, resNorm, &nEig, &nIter, &iflag), iflag);
  }

  // calculate real residual
  PHIST_ICHK_IERR(SUBR(sparseMat_times_mvec)(st::one(),A,Q,st::zero(),res,&iflag),iflag);
  PHIST_ICHK_IERR(SUBR(mvec_times_sdMat)(-st::one(),Q,R,st::one(),res,&iflag),iflag);
  PHIST_ICHK_IERR(SUBR(mvec_norm2)(res,resNormExp,&iflag),iflag);
  int nConvergedEig = 0;
  for(int i = 0; i < nEig; i++)
    if(resNorm[i] <= opts.convTol)
      nConvergedEig++;

  PHIST_SOUT(PHIST_INFO, "subspacejada terminated after %d iterations and calculated %d eigenvalues.", nIter, nConvergedEig);
  PHIST_SOUT(PHIST_INFO, "\n eigenvalues:              ");

  if( opts.symmetry==phist_HERMITIAN )
  {
    for(int i = 0; i < nEig; i++)
      PHIST_SOUT(PHIST_INFO, "\t%8.4e", ct::real(ev[i]));
    PHIST_SOUT(PHIST_INFO, "\n (est.) ritz residual norm:");
    for(int i = 0; i < nEig; i++)
      PHIST_SOUT(PHIST_INFO, "\t%8.4e", resNorm[i]);
    PHIST_SOUT(PHIST_INFO, "\n explicit residual norm:   ");
    for(int i = 0; i < nEig; i++)
      PHIST_SOUT(PHIST_INFO, "\t%8.4e", resNormExp[i]);
  }
  else
  {
    for(int i = 0; i < nEig; i++)
      PHIST_SOUT(PHIST_INFO, "\t( %8.4e + i%8.4e )", ct::real(ev[i]), ct::imag(ev[i]));
    PHIST_SOUT(PHIST_INFO, "\n (est.) ritz residual norm:");
    for(int i = 0; i < nEig; i++)
      PHIST_SOUT(PHIST_INFO, "\t%8.4e                  ", resNorm[i]);
    PHIST_SOUT(PHIST_INFO, "\n explicit residual norm:   ");
    for(int i = 0; i < nEig; i++)
      PHIST_SOUT(PHIST_INFO, "\t%8.4e                  ", resNormExp[i]);
  }
  PHIST_SOUT(PHIST_INFO, "\n");





  //------------------------------- clear matrices and vectors --------------------- 
  // delete vectors and sdMats
  PHIST_ICHK_IERR(SUBR(mvec_delete)(res,&iflag),iflag);
  delete[] ev;
  delete[] resNorm;
  delete[] resNormExp;
  PHIST_ICHK_IERR(SUBR(mvec_delete)(v0,&iflag),iflag);
  PHIST_ICHK_IERR(SUBR(sdMat_delete)(R,&iflag),iflag);
  PHIST_ICHK_IERR(SUBR(mvec_delete)(Q,&iflag),iflag);
  // clean up operator
  delete opA;
  // delete matrix
  PHIST_ICHK_IERR(SUBR(sparseMat_delete)(A,&iflag),iflag);
  PHIST_ICHK_IERR(phist_comm_delete(comm,&iflag),iflag);

  PHIST_MAIN_TASK_END

  PHIST_ICHK_IERR(phist_kernels_finalize(&iflag),iflag);
  return iflag;
}
