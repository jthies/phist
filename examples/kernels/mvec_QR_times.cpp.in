#include "phist_config.h"

#ifdef PHIST_HAVE_MPI
#include <mpi.h>
#endif

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#ifdef PHIST_HAVE_LIKWID
#include "likwid.h"
#endif

#include "phist_macros.h"
#include "phist_enums.h"
#include "phist_kernels.h"
#include "phist_operator.h"
#include "phist_driver_utils.h"
#include ${PHIST_TG_HFILE}
#include "phist_ScalarTraits.hpp"

typedef phist::ScalarTraits<_ST_> st;

//! benchmark the function mvec_QR, given k, n, m
//! do k times: randomize an n x m mvec and orthogonalize
//! it using mvec_QR.
int main(int argc, char** argv)
{
  int ierr;

  comm_ptr_t comm = NULL;
  map_ptr_t map = NULL;
  mvec_ptr_t X = NULL, Y=NULL;
  sdMat_ptr_t R = NULL;
  
  PHIST_ICHK_IERR(phist_kernels_init(&argc,&argv,&ierr),ierr);
  PHIST_ICHK_IERR(phist_comm_create(&comm,&ierr),ierr);

  if (argc!=4)
  {
    PHIST_SOUT(PHIST_ERROR,"Usage: %s n m k\n"
                           "       perform k times: \n"
                           "       randomize an n x m mvec\n"
                           "       orthogonalize its columns by mvec_QR\n"
                           "       perform other operations mvec_add_mvec, \n"
                           "       mvecT_times_mvec to check for NUMA issues etc.\n",
                           argv[0]);
    return 1;
  }

  gidx_t n;
  int m,k;
  if (sizeof(gidx_t)==4)
  {
    n=atoi(argv[1]);
  }
  else
  {
    n=atol(argv[1]);
  }
  
  m=atoi(argv[2]);
  k=atoi(argv[3]);

  PHIST_ICHK_IERR(phist_map_create(&map,comm,n,&ierr),ierr);
  PHIST_ICHK_IERR(SUBR(mvec_create)(&X,map,m,&ierr),ierr);
  PHIST_ICHK_IERR(SUBR(mvec_create)(&Y,map,m,&ierr),ierr);
  PHIST_ICHK_IERR(SUBR(sdMat_create)(&R,m,m,comm,&ierr),ierr);

  for (int it=0; it<k; it++)
  {
    // this determines the numa domains (thinking of OpenMP here)
    PHIST_ICHK_IERR(SUBR(mvec_random)(X,&ierr),ierr);
    PHIST_ICHK_IERR(SUBR(mvec_random)(Y,&ierr),ierr);
    // this is what we really want to benchmark
    PHIST_ICHK_IERR(SUBR(mvec_QR)(X,R,&ierr),ierr);
    // this is just to compare with a trivially parallel operation (axpy)
    // and an operation involving one global communication step (R=X^TY)
    _ST_ alpha=st::rand();
    _ST_ beta=st::rand();
    PHIST_ICHK_IERR(SUBR(mvec_add_mvec)(alpha,X,beta,Y,&ierr),ierr);
    PHIST_ICHK_IERR(SUBR(mvecT_times_mvec)(alpha,X,Y,beta,R,&ierr),ierr);
  }
  PHIST_ICHK_IERR(SUBR(mvec_delete)(X,&ierr),ierr);
  PHIST_ICHK_IERR(SUBR(mvec_delete)(Y,&ierr),ierr);
  PHIST_ICHK_IERR(SUBR(sdMat_delete)(R,&ierr),ierr);
  PHIST_ICHK_IERR(phist_map_delete(map,&ierr),ierr);

  PHIST_ICHK_IERR(phist_kernels_finalize(&ierr),ierr);

  return ierr;
}
