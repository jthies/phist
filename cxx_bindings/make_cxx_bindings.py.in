#!/usr/bin/python
import re       # Regular expression library
import os
import time
import csv      # To write .csv files
import sys      # To use command line arguments
import platform  # To obtain platform informations
from collections import OrderedDict

# first define some constant parts of the files that we generate

header  = \
"""/******************************************************************************************************
 * This file was automatically generated by the phist software, see https://bitbucket.org/essex/phist/ *
 * and as such is subject to the terms and conditions of the license included in that software.        *
 *******************************************************************************************************/
 """

def class_template(class_name):
    return '''
namespace phist {

template<typename ST>
'''+\
'class '+class_name+'\n'\
'''{
  typedef ST::MissingSpecializationForClass_'''+class_name+' error;\n'+\
'''};
}//namespace phist

#ifdef CLASS_DECL_HPP
#undef CLASS_DECL_HPP
#endif

'''+\
'#define CLASS_DECL_HPP '+'\"phist_'+class_name+'_decl.hpp\"\n'+\
'''
#ifdef PHIST_HAVE_SP
#include \"phist_gen_s.h\"
#include CLASS_DECL_HPP
#endif
#include "phist_gen_d.h"
#include CLASS_DECL_HPP

#ifdef PHIST_HAVE_CMPLX
#ifdef PHIST_HAVE_SP
#include "phist_gen_c.h"
#include CLASS_DECL_HPP
#endif
#include "phist_gen_z.h"
#include CLASS_DECL_HPP
#endif
'''

# loop over all subdirectories in src/ (aka modules)

src_dir="@PROJECT_SOURCE_DIR@/src/"
modules=[x[1] for x in os.walk(src_dir)][0]
for mod_name in modules:
    # skip a bunch of subdirectories
    if (mod_name=="support" or mod_name=="craft" or mod_name=="tools"):
        continue;

    mod_dir = src_dir+"/"+mod_name
    files = [x[2] for x in os.walk(mod_dir)][0]
        
    print "module "+mod_name
    
    # write the class template (module.hpp file) which is specialized in the module_decl.hpp file.
    module_hpp_file = open("phist_"+mod_name+".hpp", "w")
    module_hpp_file.write(header)

    module_includes='''
#include \"phist_config.h\"
#include \"phist_exceptions.hpp\"
'''
    for file in files:
        if (file.find("_decl")!=-1 or file.find("_def")!=-1 or file[len(file)-2:len(file)]!=".h"):
            continue
        if (file.find("driver_utils")!=-1):
            continue
        if (file.find("simple_lanczos_ft")!=-1):
            continue
        module_includes=module_includes+'\n#include \"'+file+'"'
    
    module_hpp_file.write(module_includes+'\n\n')
    module_hpp_file.write(class_template(mod_name))
    module_hpp_file.close()
     
    module_decl_file = open("phist_"+mod_name+"_decl.hpp", "w")
    module_decl_file.write(header)
    module_decl_file.write(\
    """
namespace phist 
{

  template<>
  class """+mod_name+"<_ST_>\n"+\
    """  {
                
    public:
        
""")

    for c_file_name in files:

        if (c_file_name.find("_decl") == -1):
            continue
        if (c_file_name.find("phist_MemOwner") != -1):
            continue
        print "    - process file '"+c_file_name+"'"

        whole_file = open(mod_dir + "/" + c_file_name, 'rU').read()
                
        subroutines=re.findall("SUBR\(.*\)\(.*\)\;", whole_file)
        for s in subroutines:
            name=re.findall("SUBR\((.*?)\)",s,re.DOTALL)[0]
            print "        - function '"+name+"'"
            # find second parenthesis
            i0=s.find("(")
            i1=i0+s[i0+1:len(s)].find("(")+1
            # end of argument list
            i2=s.find(");")
            args=s[i1+1:i2]
            arg_list=args.split(",");
            arg_names=''
            for arg in arg_list:
                arg_name=arg.strip().split(" ")[1]
                arg_names = arg_names+", "+arg_name
            
            arg_names=arg_names[2:len(arg_names)]
            
            module_decl_file.write(\
            "    void "+name+"("+args+")\n    {\n"+\
            "      SUBR("+name+")("+arg_names+");"+\
            """
      if (*iflag<0) throw phist::Exception(*iflag);
    }\n\n""")
                  
    
    module_decl_file.write("   };\n}")
    module_decl_file.close()
            
