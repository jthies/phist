#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

#include "esmac_constants.h"
#include "esmac_collection.h"

// includes headers of all matrix examples. Autogenerated.
#include "esmac_collection_inc.h"

esmac_generator_t * esmac_collection_example(const char * name, int * info) {
  esmac_generator_t * my_gen = malloc(sizeof * my_gen);
  
  // assume, everything will be going fine
  if (info) {*info = 0;}
  
  strncpy(my_gen->name, name, ESMAC_NAME_LENGTH);
  // in any case
  my_gen->name[ESMAC_NAME_LENGTH-1]=0;

  // if (!strcmp(name,"hubbard")) {
  //   esmac_matrix_hubbard_params_t * my_hubbard_p = malloc(sizeof * my_hubbard_p);
  //   // set default values
  //   my_hubbard_p -> t = 1.0;
  //   ...
  //   my_gen-> par = my_hubbard_p;
  //   return my_gen;
  // }
  
  //include code for all matrix examples. Autogenerated. 
#include "esmac_collection_example_inc.c"

  printf("%s: Unknown example [%s]\n",__func__,name);
  exit(EXIT_FAILURE);
  //  return NULL;
}

void esmac_collection_example_free(esmac_generator_t * gen) {
  if (gen) {
    if (gen->par) {free(gen->par);}
    free(gen);
  }
}

int esmac_collection_set_int(esmac_generator_t * gen, const char * parname, int val) {
  if (gen && parname) {
    
    #include "esmac_collection_set_int_inc.c"
    
    printf("%s: Unknown example [%s]\n",__func__,gen->name);
    exit(EXIT_FAILURE);
    return 0;
  } else {
    return ESMAC_EINVAL;
  }
}

int esmac_collection_set_double(esmac_generator_t * gen, const char * parname, double val) {
   if (gen && parname) {
    
    #include "esmac_collection_set_double_inc.c"
    
    printf("%s: Unknown example [%s]\n",__func__,gen->name);
    exit(EXIT_FAILURE);
    return 0;
  } else {
    return ESMAC_EINVAL;
  }
}

int esmac_collection_set_bool(esmac_generator_t * gen, const char * parname, bool val);
int esmac_collection_set_option(esmac_generator_t * gen, const char * parname, char * option);

char * esmac_collection_list_examples() {
  char * my_string;
  #include "esmac_collection_list_examples_inc.c"
  return my_string;
}

char * esmac_collection_list_parameters(const char * name, int * info) {
  if (name) {
    if (info) {*info = 0;}
    char * my_string;
    #include "esmac_collection_list_parameters_inc.c"
    
    printf("%s: Unknown example [%s]\n",__func__,name);
    exit(EXIT_FAILURE);
    return NULL;
  } else {
    if (info) {
      * info = ESMAC_EINVAL;
    }
    return NULL;
  }
}

int esmac_collection_identify_parameter(const char * name, const char * parname) {
  if (name && parname) {
    #include "esmac_collection_identify_parameter_inc.c"
    return -1; // not found
  } else {
    return -1;
  }
}

static char * strip_string(char * s) {
  if (s) {
    while (*s == ' ') {s++;}
    int n = strlen(s);
    while (n>0 && s[n-1] == ' ') {
      s[n-1]=0;
      n--;
    }
    return s;
  } else {
    return NULL;
  }
}

char * esmac_collection_example_data(const esmac_generator_t * gen) {
  if (gen) {
    char * my_string;
   #include "esmac_collection_example_data_inc.c"
    my_string = malloc(16 * sizeof *my_string);
    strncpy(my_string,"Unknown example",16);
    return my_string;
  } else {
    return NULL;
  }
}

static int split_string(const char *s, char **split, char ***sfst) {
  if (s) {
        
    // strdup
    char * s2;
    s2 = malloc((strlen(s)+1) * sizeof *s2);
    memcpy(s2, s, strlen(s) * sizeof *s2);
    s2[strlen(s)]=0;
    
    // first: count
    
    int n=0;
    char * s1 = s2;
     
    while (s1) {
      n++;
      s1 = strpbrk(s1, ",");
      if (s1) {s1++;}
    }
        
    // second: split
        
    char ** my_list = malloc( 2* n * sizeof *my_list);
    
    // split at ","
    s1 = s2;
    n=0;
    while (s1) {
      my_list[2*n]=s1;
      my_list[2*n+1]=NULL;
      n++;
      s1 = strpbrk(s1, ",");
      if (s1) {
        *s1=0; // NULL terminate string
        s1++;
      }
    }

    // split each at "="
    int i;
    for (i=0;i<n;i++) {
      s1 = strpbrk(my_list[2*i], "=");
      if (s1) {
	*s1=0;
	my_list[2*i+1]=s1+1;
      }
    }

    // strip
    for (i=0;i<2*n;i++) {
      if (my_list[i]) {
	my_list[i]=strip_string(my_list[i]);
      }
    }

    *split = s2;
    *sfst = my_list;
    return n;
    
  } else {
    *split=NULL;
    *sfst=NULL;
    return 0;
  }
}


esmac_generator_t * esmac_collection_parse(const char * argstring, int * info) {

  esmac_generator_t * my_gen;

  char * my_s;
  char ** my_slst;

  int n = split_string(argstring, &my_s, &my_slst);

  if (n<1) {
    printf("%s: few parameters\n",__func__);
    exit(EXIT_FAILURE);
  }

  // matrix name
  if (my_slst[1]) {
    printf("%s: matrix name accepts no values\n",__func__);
    exit(EXIT_FAILURE);
  } 
  if (!my_slst[0]) {
    printf("%s: matrix name required\n",__func__);
    exit(EXIT_FAILURE);
  }

  my_gen = esmac_collection_example(my_slst[0], info);


  if (*info) {
    printf("%s: matrix example does not exist\n",__func__);
    exit(EXIT_FAILURE);
  }

  char * my_par = esmac_collection_list_parameters(my_slst[0], info);
  
  if (*info) {
    printf("%s: matrix example has no parameters\n",__func__);
    exit(EXIT_FAILURE);
  }
  
  
  // set parameters
  int i;
  for (i=1;i<n;i++) {
    int par_type = esmac_collection_identify_parameter(my_slst[0],my_slst[2*i]);
    if (par_type < 0) {
      printf("%s: Parameter %s does not exist\n",__func__,my_slst[2*i]);
      exit(EXIT_FAILURE);
    }
    if (par_type == ESMAC_PAR_INT) {
      if (!my_slst[2*i+1]) {
        printf("%s: Parameter %s requires INT value\n",__func__,my_slst[2*i]);
        exit(EXIT_FAILURE);
      }
      esmac_collection_set_int(my_gen, my_slst[2*i], atoi(my_slst[2*i+1]) );
    } else if (par_type == ESMAC_PAR_DOUBLE) {
      if (!my_slst[2*i+1]) {
        printf("%s: Parameter %s requires DOUBLE value\n",__func__,my_slst[2*i]);
        exit(EXIT_FAILURE);
      }
      esmac_collection_set_double(my_gen, my_slst[2*i], atof(my_slst[2*i+1]) );
    } else {
      printf("%s: Unknown parameter type\n",__func__);
      exit(EXIT_FAILURE);
    }
  }

  if (my_par) {free(my_par);  }

  return my_gen;

}

